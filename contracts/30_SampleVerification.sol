//SPDX-License-Identifier: MIT

pragma solidity 0.8.18;

contract MyContract {
    mapping(address => uint256) public balance;

    constructor() {
        balance[msg.sender] = 100;
    }

    function transfer(address _to, uint256 _amount) public {
        balance[msg.sender] -= _amount;
        balance[_to] += _amount;
    }

    /* 
    Sometimes Etherscan infers a function name. That is, for interfaces from known 
    contracts, like the ERC20 contract. If you interact with this smart contract and 
    use the transfer function, Etherscan would probably show you correctly that the 
    function "transfer" was used. But if you use the function someRandomCrypticFunctionName 
    it would just show you the 4 byte hashed function signature.
    */
    function someRandomCrypticFunctionName(address _addr) public view returns (uint256)
    {
        return balance[_addr];
    }
}

// To Verify A Smart Contract manually on Etherscan and read/write a contract using block explorer -:
/* 
1. Sign in to Etherscan
2. Deploy the above contract in remix, in injected provider, and from console, go on `view on etherscan`
to open the transaction on Etherscan.
3. Click on the new Contract (the address) to open the contract.
4. Then click on the Contract - you see its just bytecode there. Etherscan can't guess your interface, 
   your function names, nothing -> That's the unverified bytecode.
5. Let's verify that Smart Contract now! Click "Verify and Publish".
6. There are two things to select: The compiler and the license -> Select Solidity single-file from the compiler
   & Once you select Solidity, another dropdown will appear for the compiler version.
7. Select 0.8.18, or whatever compiler you used for your contract and license this contract as MIT.
8. Click on Continue, now we need to copy the source code from Remix into the source code field.
9. Sometimes you need to specify the compiler optimizations. To check if you had any, head back to Remix, 
   and click "Advanced Configurations" in the compiler plugin.
10. Finally, our Bytecode and the ABI Array -> all green!
11. It should say something like "Successfully generated ByteCode and ABI for Contract Address "
12. Click on your contract address to get back.
13. Click "Contract" - which now has a little check next to it.
14. Click "Read Contract" -> You see, now you have even the most crypto function names as cleartext here to interact with.
15. Let's interact with our smart contract. Click "Write" -> Click "Connect to Web3".
16. Confirm the dialog box & Select "MetaMask" from the options.
17. Select "Account 1" to connect & Next, then Click "Connect", then "1. transfer".
18. Now, copy & paste the second account address from MetaMask and then Click "amount (uint256)" -> click write and confirm.
19. Click "Read Contract" -> lets read out the balance. Click "1. balance" and paste in the same account that 
    we used for transferring the funds to.
20. And simple click "Query", it should show you "1" as balance.
*/